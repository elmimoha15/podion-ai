from fastapi import APIRouter, HTTPException, status, Depends, Query
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import logging
from utils.firebase_auth import get_current_user_id
from utils.firebase_firestore import (
    save_podcast_metadata,
    get_podcast_metadata,
    list_user_podcasts,
    update_podcast_metadata,
    delete_podcast_metadata,
    search_podcasts_by_title,
    get_podcast_stats,
    save_complete_podcast_workflow,
    get_firestore_client
)
from google.cloud import firestore

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create router
router = APIRouter()

# Pydantic models
class PodcastMetadataRequest(BaseModel):
    user_id: str = Field(..., description="User ID who owns the podcast")
    filename: str = Field(..., description="Original filename")
    audio_url: str = Field(..., description="Public URL to audio file")
    transcript: str = Field(..., description="Full transcript text")
    deepgram_words: List[Dict[str, Any]] = Field(..., description="Word-level timestamps from Deepgram")
    gemini_seo_content: Dict[str, Any] = Field(..., description="SEO content generated by Gemini")
    storage_path: Optional[str] = Field(None, description="Firebase Storage path")
    file_size: Optional[int] = Field(None, description="File size in bytes")
    processing_metadata: Optional[Dict[str, Any]] = Field(None, description="Additional processing info")

class PodcastResponse(BaseModel):
    success: bool
    doc_id: Optional[str] = None
    podcast_data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class PodcastListResponse(BaseModel):
    success: bool
    podcasts: Optional[List[Dict[str, Any]]] = None
    count: Optional[int] = None
    user_id: Optional[str] = None
    error: Optional[str] = None

class PodcastStatsResponse(BaseModel):
    success: bool
    stats: Optional[Dict[str, Any]] = None
    user_id: Optional[str] = None
    error: Optional[str] = None

class WorkflowSaveRequest(BaseModel):
    user_id: str = Field(..., description="User ID")
    filename: str = Field(..., description="Original filename")
    audio_url: str = Field(..., description="Public audio URL")
    storage_path: str = Field(..., description="Firebase Storage path")
    file_size: int = Field(..., description="File size in bytes")
    transcript_response: Dict[str, Any] = Field(..., description="Complete transcription response")
    seo_response: Dict[str, Any] = Field(..., description="Complete SEO generation response")

@router.post("/save-podcast", response_model=PodcastResponse)
async def save_podcast_metadata_endpoint(request: PodcastMetadataRequest):
    """
    Save podcast metadata to Firestore
    
    Stores complete podcast information including:
    - User and file information
    - Full transcript and word-level timestamps
    - All SEO content generated by Gemini
    - Processing metadata and timestamps
    """
    
    try:
        logger.info(f"Saving podcast metadata for user {request.user_id}: {request.filename}")
        
        doc_id = save_podcast_metadata(
            user_id=request.user_id,
            filename=request.filename,
            audio_url=request.audio_url,
            transcript=request.transcript,
            deepgram_words=request.deepgram_words,
            gemini_seo_content=request.gemini_seo_content,
            storage_path=request.storage_path,
            file_size=request.file_size,
            processing_metadata=request.processing_metadata
        )
        
        logger.info(f"Podcast metadata saved successfully: {doc_id}")
        
        return PodcastResponse(
            success=True,
            doc_id=doc_id
        )
        
    except Exception as e:
        logger.error(f"Failed to save podcast metadata: {str(e)}")
        
        return PodcastResponse(
            success=False,
            error=f"Failed to save podcast metadata: {str(e)}"
        )

@router.post("/save-workflow", response_model=PodcastResponse)
async def save_complete_workflow_endpoint(request: WorkflowSaveRequest):
    """
    Save complete podcast workflow results to Firestore
    
    Convenience endpoint that takes the full responses from:
    - Transcription service (Deepgram)
    - SEO generation service (Gemini)
    - Storage service (Firebase Storage)
    
    And saves everything in a structured format.
    """
    
    try:
        logger.info(f"Saving complete workflow for user {request.user_id}: {request.filename}")
        
        doc_id = save_complete_podcast_workflow(
            user_id=request.user_id,
            filename=request.filename,
            audio_url=request.audio_url,
            storage_path=request.storage_path,
            file_size=request.file_size,
            transcript_response=request.transcript_response,
            seo_response=request.seo_response
        )
        
        logger.info(f"Complete workflow saved successfully: {doc_id}")
        
        return PodcastResponse(
            success=True,
            doc_id=doc_id
        )
        
    except Exception as e:
        logger.error(f"Failed to save complete workflow: {str(e)}")
        
        return PodcastResponse(
            success=False,
            error=f"Failed to save workflow: {str(e)}"
        )

@router.get("/podcast/{doc_id}", response_model=PodcastResponse)
async def get_podcast_by_id(doc_id: str):
    """
    Retrieve podcast metadata by document ID
    
    Returns all stored information including transcript, SEO content,
    and processing metadata.
    """
    
    try:
        logger.info(f"Retrieving podcast metadata: {doc_id}")
        
        podcast_data = get_podcast_metadata(doc_id)
        
        return PodcastResponse(
            success=True,
            doc_id=doc_id,
            podcast_data=podcast_data
        )
        
    except HTTPException:
        # Re-raise HTTP exceptions (like 404)
        raise
    except Exception as e:
        logger.error(f"Failed to retrieve podcast: {str(e)}")
        
        return PodcastResponse(
            success=False,
            error=f"Failed to retrieve podcast: {str(e)}"
        )

@router.get("/podcasts/user/{user_id}", response_model=PodcastListResponse)
async def list_user_podcasts_endpoint(user_id: str, limit: int = 50):
    """
    List all podcasts for a specific user
    
    Returns podcasts ordered by creation date (newest first).
    """
    
    try:
        if limit > 100:
            limit = 100
        
        logger.info(f"Listing podcasts for user {user_id} (limit: {limit})")
        
        podcasts = list_user_podcasts(user_id=user_id, limit=limit)
        
        logger.info(f"Found {len(podcasts)} podcasts for user {user_id}")
        
        return PodcastListResponse(
            success=True,
            podcasts=podcasts,
            count=len(podcasts),
            user_id=user_id
        )
        
    except Exception as e:
        logger.error(f"Failed to list podcasts for user {user_id}: {str(e)}")
        
        return PodcastListResponse(
            success=False,
            user_id=user_id,
            error=f"Failed to list podcasts: {str(e)}"
        )

@router.get("/podcasts/search/{user_id}", response_model=PodcastListResponse)
async def search_user_podcasts(user_id: str, query: str, limit: int = 20):
    """
    Search podcasts by filename/title for a specific user
    
    Simple text search on podcast filenames.
    """
    
    try:
        logger.info(f"Searching podcasts for user {user_id}: '{query}'")
        
        podcasts = search_podcasts_by_title(
            user_id=user_id,
            title_query=query,
            limit=limit
        )
        
        logger.info(f"Found {len(podcasts)} matching podcasts")
        
        return PodcastListResponse(
            success=True,
            podcasts=podcasts,
            count=len(podcasts),
            user_id=user_id
        )
        
    except Exception as e:
        logger.error(f"Failed to search podcasts: {str(e)}")
        
        return PodcastListResponse(
            success=False,
            user_id=user_id,
            error=f"Failed to search podcasts: {str(e)}"
        )

@router.get("/podcast/upload/{upload_id}", response_model=PodcastResponse)
async def get_podcast_by_upload_id(upload_id: str, user_id: str = Depends(get_current_user_id)):
    """
    Retrieve podcast metadata by upload_id
    
    This endpoint allows fetching a podcast using the upload_id returned
    from the quick upload process, which is useful for navigation after
    upload completion.
    """
    
    try:
        logger.info(f"Retrieving podcast by upload_id: {upload_id} for user: {user_id}")
        
        # Search for podcast with matching upload_id in processing metadata
        from utils.firebase_firestore import get_firestore_client
        
        db = get_firestore_client()
        
        # Query main podcasts collection to find matching upload_id
        podcasts_ref = db.collection('podcasts')
        
        # Search for podcast with this upload_id in processing info and user_id
        query = podcasts_ref.where('processing_info.upload_id', '==', upload_id).where('user_id', '==', user_id).limit(1)
        docs = query.stream()
        
        podcast_doc = None
        doc_id = None
        
        for doc in docs:
            podcast_doc = doc.to_dict()
            doc_id = doc.id
            break
        
        if not podcast_doc:
            logger.warning(f"No podcast found with upload_id: {upload_id} for user: {user_id}")
            raise HTTPException(
                status_code=404,
                detail=f"Podcast with upload_id {upload_id} not found"
            )
        
        logger.info(f"Found podcast {doc_id} for upload_id: {upload_id}")
        
        return PodcastResponse(
            success=True,
            doc_id=doc_id,
            podcast_data=podcast_doc
        )
        
    except HTTPException:
        # Re-raise HTTP exceptions (like 404)
        raise
    except Exception as e:
        logger.error(f"Failed to retrieve podcast by upload_id: {str(e)}")
        
        raise HTTPException(
            status_code=500,
            detail=f"Failed to retrieve podcast: {str(e)}"
        )

@router.delete("/podcast/{doc_id}")
async def delete_podcast_by_id(doc_id: str, user_id: str = Depends(get_current_user_id)):
    """
    Delete a podcast by document ID
    
    Only the owner of the podcast can delete it.
    """
    
    try:
        logger.info(f"Deleting podcast {doc_id} for user: {user_id}")
        
        from utils.firebase_firestore import get_firestore_client
        
        db = get_firestore_client()
        
        # Get the podcast document from the main podcasts collection
        podcast_ref = db.collection('podcasts').document(doc_id)
        podcast_doc = podcast_ref.get()
        
        if not podcast_doc.exists:
            logger.warning(f"Podcast {doc_id} not found")
            raise HTTPException(
                status_code=404,
                detail=f"Podcast {doc_id} not found"
            )
        
        # Verify ownership
        podcast_data = podcast_doc.to_dict()
        if podcast_data.get('user_id') != user_id:
            logger.warning(f"User {user_id} does not own podcast {doc_id}")
            raise HTTPException(
                status_code=403,
                detail="You don't have permission to delete this podcast"
            )
        
        # Delete the podcast document
        podcast_ref.delete()
        
        logger.info(f"Successfully deleted podcast {doc_id} for user: {user_id}")
        
        return {
            "success": True,
            "message": f"Podcast {doc_id} deleted successfully"
        }
        
    except HTTPException:
        # Re-raise HTTP exceptions (like 404)
        raise
    except Exception as e:
        logger.error(f"Failed to delete podcast {doc_id}: {str(e)}")
        
        raise HTTPException(
            status_code=500,
            detail=f"Failed to delete podcast: {str(e)}"
        )

@router.get("/podcasts/stats/{user_id}", response_model=PodcastStatsResponse)
async def get_user_podcast_stats(user_id: str):
    """
    Get statistics about a user's podcasts
    
    Returns aggregated data like total podcasts, storage used,
    transcript words, average speakers, etc.
    """
    
    try:
        logger.info(f"Getting podcast stats for user {user_id}")
        
        stats = get_podcast_stats(user_id)
        
        return PodcastStatsResponse(
            success=True,
            stats=stats,
            user_id=user_id
        )
        
    except Exception as e:
        logger.error(f"Failed to get podcast stats: {str(e)}")
        
        return PodcastStatsResponse(
            success=False,
            user_id=user_id,
            error=f"Failed to get podcast stats: {str(e)}"
        )

@router.put("/podcast/{doc_id}")
async def update_podcast(doc_id: str, updates: Dict[str, Any]):
    """
    Update specific fields in podcast metadata
    
    Allows partial updates to podcast documents.
    """
    
    try:
        logger.info(f"Updating podcast metadata: {doc_id}")
        
        success = update_podcast_metadata(doc_id, updates)
        
        if success:
            return {"success": True, "doc_id": doc_id, "message": "Podcast updated successfully"}
        else:
            return {"success": False, "error": "Failed to update podcast"}
        
    except Exception as e:
        logger.error(f"Failed to update podcast: {str(e)}")
        
        return {"success": False, "error": f"Failed to update podcast: {str(e)}"}

@router.delete("/podcast/{doc_id}")
async def delete_podcast(doc_id: str):
    """
    Delete podcast metadata from Firestore
    
    Warning: This only deletes the metadata. Audio files in Firebase Storage
    must be deleted separately if needed.
    """
    
    try:
        logger.info(f"Deleting podcast metadata: {doc_id}")
        
        success = delete_podcast_metadata(doc_id)
        
        if success:
            return {"success": True, "doc_id": doc_id, "message": "Podcast deleted successfully"}
        else:
            return {"success": False, "error": "Failed to delete podcast"}
        
    except Exception as e:
        logger.error(f"Failed to delete podcast: {str(e)}")
        
        return {"success": False, "error": f"Failed to delete podcast: {str(e)}"}

@router.get("/podcasts/workspace/{workspace_id}")
async def get_workspace_podcasts(
    workspace_id: str,
    user_id: str = Depends(get_current_user_id),
    limit: int = Query(50, description="Maximum number of podcasts to return")
):
    """
    Get all podcasts for a specific workspace
    
    Returns podcasts ordered by creation date (newest first)
    """
    try:
        logger.info(f"Fetching podcasts for workspace {workspace_id}, user {user_id}")
        
        db = get_firestore_client()
        
        # Query podcasts by workspace_id and user_id
        # Note: Removed ordering to avoid composite index requirement
        query = db.collection("podcasts") \
                 .where("user_id", "==", user_id) \
                 .where("workspace_id", "==", workspace_id) \
                 .limit(limit)
        
        docs = query.stream()
        podcasts = []
        
        for doc in docs:
            podcast_data = doc.to_dict()
            podcast_data["id"] = doc.id
            podcasts.append(podcast_data)
        
        # Sort by creation date (newest first) on the server side
        podcasts.sort(key=lambda x: x.get('metadata', {}).get('created_at', 0), reverse=True)
        
        logger.info(f"Retrieved {len(podcasts)} podcasts for workspace {workspace_id}")
        
        return {
            "success": True,
            "podcasts": podcasts,
            "count": len(podcasts),
            "workspace_id": workspace_id,
            "user_id": user_id
        }
        
    except Exception as e:
        logger.error(f"Failed to fetch workspace podcasts: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to fetch workspace podcasts: {str(e)}"
        )

@router.get("/firestore")
async def firestore_service_info():
    """Get information about the Firestore podcast metadata service"""
    return {
        "message": "Firebase Firestore service for podcast metadata management",
        "collection": "podcasts",
        "document_naming": "podcast_{timestamp}_{uuid}",
        "features": [
            "Save complete podcast workflow results",
            "Store transcript and word-level timestamps",
            "Store all SEO content from Gemini",
            "User-specific podcast organization",
            "Search and filtering capabilities",
            "Podcast statistics and analytics",
            "Update and delete operations"
        ],
        "data_structure": {
            "user_id": "string",
            "filename": "string", 
            "audio_url": "string",
            "storage_path": "string",
            "file_size": "number",
            "transcript": {
                "full_text": "string",
                "word_count": "number",
                "source": "deepgram_nova2"
            },
            "deepgram_data": {
                "words": "array of word objects with timestamps",
                "speakers_detected": "number",
                "model": "nova-2"
            },
            "seo_content": {
                "seo_title": "string",
                "show_notes": "array",
                "blog_post": "object",
                "social_media": "object"
            },
            "metadata": {
                "created_at": "timestamp",
                "updated_at": "timestamp",
                "processing_status": "string"
            }
        },
        "endpoints": {
            "save": "POST /save-podcast - Save podcast metadata",
            "save_workflow": "POST /save-workflow - Save complete workflow results",
            "get": "GET /podcast/{doc_id} - Get podcast by ID",
            "list": "GET /podcasts/user/{user_id} - List user podcasts",
            "search": "GET /podcasts/search/{user_id}?query=... - Search podcasts",
            "stats": "GET /podcasts/stats/{user_id} - Get user statistics",
            "update": "PUT /podcast/{doc_id} - Update podcast",
            "delete": "DELETE /podcast/{doc_id} - Delete podcast"
        },
        "integration": {
            "storage": "Works with Firebase Storage for audio files",
            "transcription": "Stores Deepgram transcription results",
            "seo": "Stores Gemini SEO content generation results",
            "workflow": "Complete podcast processing pipeline"
        }
    } 